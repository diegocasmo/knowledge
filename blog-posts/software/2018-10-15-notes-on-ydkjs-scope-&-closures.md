# Notes on YDKJS: Scope & Closures

The following are my set of notes after reading the second book "Scope & Closures" from the book series "You Don’t Know JS (YDKJS)." This blog post is essentially a reference for my future self of the topics covered in the book, not a deep explanation of them. As a result, these notes are primarily intended for people who are either already familiar with these topics, or have read the book in the past. Otherwise, I highly recommend you to read [the book](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&%20closures/README.md#you-dont-know-js-scope--closures) (it’s free!) if you are interested in learning more about these topics.

### Chapter 1: Scope
* Variables are what allow a program to have state, and when a variable is declared, it’s associated to a scope. Scope is a set of rules which dictate how variable values are found at a specific location. To better understand the concept of scope, it’s helpful to introduce the concepts of engine (responsible for compilation and execution), compiler (parsing and code generation), and scope (a look-up list of all declared variables that enforces an accessibility set of rules). When a variable is assigned a value, the compiler creates a variable (if not already declared) in the current scope, and second, when executing, the engine looks up the variable in scope and assigns to it, if found.
* Scopes are nested, if a variable value cannot be found in the current scope, the engine consults the next outer containing scope, and so on until the global scope is reached. There are two type of look-ups that can happen when code is executed: Left-Hand-Side (LHS) and Right-Hand-Side (RHS). LHS look-up happens when assigning a value to a variable (who’s the target of the assignment?), while RHS look-up asks for the value of a variable (who’s the source of the assignment?). If an RHS look-up fails to ever find a variable, it will result in a "ReferenceError" being thrown by the engine, if it’s an LHS look-up, if the program is not running in "Strict Mode", then the global scope will implicitly create a new variable of that name in the global scope and hand it back to the engine (in "Strict Mode", there’s no implicit global variable creation, so it will result in a "ReferenceError"). Thus, a "ReferenceError" is scope resolution-failure related, while a "TypeError" implies that scope resolution was successful, but that there was an illegal action tempted against the result.

### Chapter 2: Lexical Scope
* Lexical scope is scope that is defined at lexing time, that is, scope determined at author-time decisions of where functions are declared. The lexing phase of compilation consists of knowing where and how identifiers are declared, and thus predict how they will be looked up during execution. It’s possible to cheat lexical scope using methods such as "eval(...)" and "with", but these methods will most likely lead to poor performance due the JavaScript engine not performing any optimizations at all (it pessimistically assumes that such optimizations will be invalid).

### Chapter 3: Function Versus Block Scope
* Functions are the most common unit of scope in JavaScript. Function scope encourages the idea that all variables belong to the function, and can be used and reused throughout the entirety of them (even accessible to nested scopes). This is closely related to the Principle of Least Privilege, which refers to only exposing what is minimally necessary, and hiding everything else. Using scopes allows to facilitate collision avoidance as well. This happens when two or more identifiers with the same name but different intended usages are declared.
* While it’s possible to use functions to "hide" any enclosed variables from the outside scope, this is not always ideal, since it needs a function to be declared and the function identifier effectively "pollutes" the enclosing scope. Use a function expression instead, which is different from a standard function declaration in that its identifier is only declared inside the function itself, which means it does not pollute the enclosing scope. There are also anonymous function expressions which no name identifier, and consequently could lead to several drawbacks such as no useful name to display on stack traces and less readability. Instead, favor inline function expressions.
* Finally, block as scopes refers to the idea that variables and functions can belong to an arbitrary block (rather than only to functions). The "let" keyword attaches a variable declaration to the scope of whatever block it’s contained in, while the "const" keyword creates a block-scoped variable, but whose value is fixed (constant).

### Chapter 4: Hoisting
* Variable and function declarations are hoisted ("moved") to the top of their containing scope. This is the case because the engine first compiles the code before it’s interpreted, and during the compilation phase, it finds and associates all declarations with their appropriate scopes. In other words, all declarations in a scope are processed first before the code is executed. It’s also important to note that functions are hoisted first, and then variables. Finally, only declarations are hoisted, assignments are not.

### Chapter 5: Scope Closure
* A closure allows a function to continue to access the lexical scope it was defined in at author time. In other words, it is when a function can remember and access its lexical scope even when it’s invoked outside its lexical scope.
